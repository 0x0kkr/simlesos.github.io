<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0x0kkr&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-22T09:16:57.817Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS基于时间的动画</title>
    <link href="http://yoursite.com/2016/01/01/js-animation/"/>
    <id>http://yoursite.com/2016/01/01/js-animation/</id>
    <published>2016-01-01T00:00:00.000Z</published>
    <updated>2020-10-22T09:16:57.817Z</updated>
    
    <content type="html"><![CDATA[<p>说起前端动画,不得不提 CSS 动画和 JS 动画,这里简单谈谈这两者.</p><p>CSS 动画简单方便,在样式表中就可以管理动画的内容,但相应的可维护性也随之降低;对动画的控制能力不足,比如说拖拽动画等等无法实现;放弃了物理动效的支持,只能通过缓动函数来模拟.<br>相比之 JS 动画则依托完备的编程语言,可以对动效的设计进行无限的控制,虽然编写起来相比 CSS 动画来说较为复杂,但可以通过一些第三方库来快速实现,比如 <a href="http://julian.com/research/velocity/">VelocityJS</a> . 当然,事物的好坏永远需要按场景区分, CSS 动画和 JS 动画也是如此,比如说一个简单的按钮 hover 效果,无论怎么看 CSS 动画都是第一选择,但是如果需要控制一个动画工作流,那 JS 动画一定更适合了.</p><a id="more"></a><p>有点跑题了…, 回到正文</p><h2 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h2><p>假如现在我们有这样一个需求 <code>让一个 div 向右边移动 300px 的距离</code>，我们来看看下面这种实现：</p><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/dq7Ldctf/embedded/js,result/light" frameborder="0" loading="lazy" allowfullscreen></iframe><p>看起来我们实现了这个需求，不过不要急,我们稍稍修改上面代码中的 step 函数,在其中加入这段代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="number">200</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">while</span> (+<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt; <span class="number">1000</span>) &#123;&#125; <span class="comment">//阻塞1s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以去 jsfiddle 中加入这段代码，观察后，不难发现这个 div 在 left 值为 200px 的地方停顿了 1000+ms。大家都知道 js 是基于事件模型的，我们在 step 函数中 setInterval 其实相当于告诉引擎,帮我在 16.7 毫秒后将这个回调函数加入事件队列,如果引擎空闲就执行,此时我们 while 循环 1 秒，就会阻塞整个事件队列的运行，也就阻塞了 UI 线程的渲染，表现出来结果就是我们的 div 运动停止了 1 秒多。</p><p>这里虽然是人为的加入了阻塞代码，但是在正常的开发过程中，setInterval 和 setTimeout 根本没法保证按我们要求的在固定的间隔执行事件，此时如果我们的动画还是按照 <code>变化量/帧</code> 的方式来执行，就会出现不同设备中动画执行时间不同的情况,在移动端是重灾区。</p><h2 id="基于时间的动画"><a href="#基于时间的动画" class="headerlink" title="基于时间的动画"></a>基于时间的动画</h2><p>在讨论上面所述的问题该如何解决之前，不妨先来看看这个数学题:</p><blockquote><p>A 地和 B 地相距 300m，一辆速度为 5m/s 匀速运动的自行车从 A 地出发去往 B 地,请问一分钟后自行车距离 A 地多远?</p></blockquote><p>我们用时间 时间 _ 速度 即可得出 5 _ 60 = 300,也就是 300m，从这个简单的问题中，我们可以发现我们不必去寄人篱下一帧帧的做动效，不必去管帧率的问题,我们可以从动画开始时间到当前时间计算出动画经过的时间，通过 时间 * 速度，计算出当前动画的偏移量，这样就可以保证我们所有性能的平台下动画都是一个速度进行着。下面我们来修改下上面的代码:</p><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/rbdk6z79/embedded/js,result/light" frameborder="0" loading="lazy" allowfullscreen></iframe><p>这里我们改为根据时间来计算偏移量，我的测试环境中弹出的结果应该在 <code>4801</code>，下面我们来看看加入同样阻塞代码后的用时，是不是也增加了 1000 毫秒那:</p><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/2yr24asu/embedded/js,result/light" frameborder="0" loading="lazy" allowfullscreen></iframe><p>我的测试环境弹出的是 <code>4865</code>，可以看出虽然加入了阻塞代码，但是因为我们是按照时间来计算偏移量的，所以动画总时间不会偏差过大，各个平台下动画也不会出现有的快有的慢得情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基于时间的动效能够消除不同设备不同环境下动画帧数不同导致的动效速度不同的问题，推荐所有的动效都应该采用基于时间的方式!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起前端动画,不得不提 CSS 动画和 JS 动画,这里简单谈谈这两者.&lt;/p&gt;
&lt;p&gt;CSS 动画简单方便,在样式表中就可以管理动画的内容,但相应的可维护性也随之降低;对动画的控制能力不足,比如说拖拽动画等等无法实现;放弃了物理动效的支持,只能通过缓动函数来模拟.&lt;br&gt;相比之 JS 动画则依托完备的编程语言,可以对动效的设计进行无限的控制,虽然编写起来相比 CSS 动画来说较为复杂,但可以通过一些第三方库来快速实现,比如 &lt;a href=&quot;http://julian.com/research/velocity/&quot;&gt;VelocityJS&lt;/a&gt; . 当然,事物的好坏永远需要按场景区分, CSS 动画和 JS 动画也是如此,比如说一个简单的按钮 hover 效果,无论怎么看 CSS 动画都是第一选择,但是如果需要控制一个动画工作流,那 JS 动画一定更适合了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>HTML5新增元素介绍</title>
    <link href="http://yoursite.com/2015/11/01/new-tag-from-html5/"/>
    <id>http://yoursite.com/2015/11/01/new-tag-from-html5/</id>
    <published>2015-11-01T00:00:00.000Z</published>
    <updated>2020-10-22T09:16:57.817Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5 新增了一些元素为了用于更好的文档结构，使用这<br>些标签能让章节和标题特性更精确，使得文档大纲变的可预测，结构更 Semantic！</p><a id="more"></a><h3 id="section"><a href="#section" class="headerlink" title="section"></a>section</h3><p><code>section</code> 元素表示一般意义上的区域/章节，，比如内容中的一个专题，一般会与<code>h1</code>~<code>h6</code>等元素搭配使用，以标示文档层级。如果元素内容可以分为几个部分的话，应该使用 <code>article</code> 而不是 <code>section</code>。不要把 <code>section</code> 元素作为一个普通的容器来使用，这种情况下 <code>div</code> 元素比他更合适，特别是仅仅用作美化样式的情况下。通常来说 <code>section</code> 应该出现在文档的框架中。</p><h3 id="article"><a href="#article" class="headerlink" title="article"></a>article</h3><p><code>article</code> 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，它可能是论坛帖子、文章、博客、用户提交评论或者是其它的独立内容项目。当 <code>article</code> 元素嵌套使用时，则该元素代表与外层元素有关的文章，例如代表博客评论的 <code>article</code> 元素可嵌套在代表博客文章的 <code>article</code> 元素中。</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p><code>main</code> 元素呈现了文档 <code>body</code> 或应用的主体部分，这部分内容在文档中应该是独一无二的，在一个文档中不能出现一个以上的 <code>main</code>,不能是以下元素的继承 <code>article</code>,<code>aside</code>,<code>footer</code>,<code>header</code>,<code>nav</code>。</p><h3 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h3><p><code>aside</code> 元素代表与了一些与页面其他部分关联性不是那么大的内容，比如广告。</p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p><code>header</code> 代表了一组介绍性或者导航性质的辅助内容，可能包含标题元素，也可以包含其他元素，像 logo、分节头部、搜索表单等。<code>header</code> 不是分节元素，不会引入分节到大纲中。</p><h3 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h3><p><code>footer</code> 元素表示最近的一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节坐着、版权数据或者文档相关的链接信息。</p><h3 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h3><p><code>nav</code> 代表一个含有多个超链接的区域。</p><h3 id="figure"><a href="#figure" class="headerlink" title="figure"></a>figure</h3><p><code>figure</code> 代表一个独立的内容流，常与 <code>figcaption</code> 元素一起出现。</p><h3 id="figcaption"><a href="#figcaption" class="headerlink" title="figcaption"></a>figcaption</h3><p><code>figcaption</code> 用作 <code>figure</code> 的标题，类似于表格的 <code>caption</code> 元素。</p><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p><code>template</code> 元素是一种机制，允许包含加载页面时不渲染，但又可以随后通过 Javascript 实力化的客户端内容，就像我们这样做一样<code>script type=&quot;text/temple&quot;</code>。</p><h3 id="audio-amp-video"><a href="#audio-amp-video" class="headerlink" title="audio &amp; video"></a>audio &amp; video</h3><p><code>audio</code> 和 <code>video</code> 是多媒体元素，他们提供相对应的 API 用于开发者定制 UI，同时也提供了出发 UA 展示其默认控件的方式。</p><h3 id="embed"><a href="#embed" class="headerlink" title="embed"></a>embed</h3><p><code>embed</code> 元素表示一个插件，展用于插件内容。</p><h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><p><code>mark</code> 元素代表了一个文档中需要标记或者高亮的部分，比如说搜索引擎搜索后的关键词。不要为了语法高亮而去使用 mark，应该使用 <code>strong</code> 元素，<code>mark</code> 元素表示上下文的关联性。</p><h3 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h3><p><code>progress</code> 用来表示一个进度条,代表一个任务的完成进度。</p><h3 id="meter"><a href="#meter" class="headerlink" title="meter"></a>meter</h3><p><code>meter</code> 代表了一个度量，比如对磁盘空间的度量。</p><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p><code>time</code> 表示一个时间。有两个属性,datetime(一个有效的时间格式，表示具体时间),pubdate(一般用于文章发布时间，评论回复时间等)。</p><h3 id="ruby、rt、rp"><a href="#ruby、rt、rp" class="headerlink" title="ruby、rt、rp"></a>ruby、rt、rp</h3><p><code>ruby</code>、<code>rt</code>、<code>rp</code> 代表 Ruby 表达式。</p><h3 id="bdi"><a href="#bdi" class="headerlink" title="bdi"></a>bdi</h3><p><code>bdi</code> 代表了一段隔绝于周围元素的双向书写文本格式。</p><h3 id="wbr"><a href="#wbr" class="headerlink" title="wbr"></a>wbr</h3><p><code>bdi</code> 代表了可能断行的部分。</p><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p><code>canvas</code> 用于渲染动态位图。</p><h3 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h3><p><code>datalist</code> 与 input 的 list 属性共同使用，可以用于创建下拉选择框控件。</p><h3 id="keygen"><a href="#keygen" class="headerlink" title="keygen"></a>keygen</h3><p><code>keygen</code> 代表生成的密钥对。</p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p><code>output</code> 代表了一种输出内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5 新增了一些元素为了用于更好的文档结构，使用这&lt;br&gt;些标签能让章节和标题特性更精确，使得文档大纲变的可预测，结构更 Semantic！&lt;/p&gt;
    
    </summary>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>重排与重绘</title>
    <link href="http://yoursite.com/2015/09/01/repaints-and-reflows/"/>
    <id>http://yoursite.com/2015/09/01/repaints-and-reflows/</id>
    <published>2015-09-01T00:00:00.000Z</published>
    <updated>2020-10-22T09:16:57.817Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器下载完页面中的组件后，会解析并生成两个内部数据结构－－DOM 树(表示页面结构)、渲染树(表示 DOM 节点如何显示)。每当 DOM 元素的几何属性发生变化时（宽高发生变化、内容改编、位置发生变化等等），浏览器就需要重新计算变化元素和受影响的其他元素的几何属性。浏览器会使渲染树中受影响的部分失效，并重新构建渲染树，这个过程叫重排。重排完成后，浏览器会根据渲染树，把受影响的部分重新绘制到屏幕上，这个过程叫重绘。</p><p>重排和重绘都是相当消耗性能的操作，它们会导致 Web 页面 UI 反应迟钝。应当尽量减少重排和重绘。</p><a id="more"></a><h2 id="何时重排"><a href="#何时重排" class="headerlink" title="何时重排"></a>何时重排</h2><ol><li>页面渲染器初始化的时候</li><li>浏览器窗口发生尺寸变化时</li><li>删除或添加新的可见 DOM 元素</li><li>元素的位置改变</li><li>元素的盒子模型发生变化</li><li>元素内容发生变化（引起盒子模型发生变化）</li></ol><h2 id="减少重排和重绘"><a href="#减少重排和重绘" class="headerlink" title="减少重排和重绘"></a>减少重排和重绘</h2><p>每次重绘和重排都会产生大量消耗，我们在编码时应当避免。</p><h3 id="渲染树队列与刷新"><a href="#渲染树队列与刷新" class="headerlink" title="渲染树队列与刷新"></a>渲染树队列与刷新</h3><p>大多数浏览器都会优化这个队列，通过批量执行等方式来优化重排过程，然而你可能会不经意间强制要求浏览器放弃优化，立即执行队列并刷新。</p><p>调用下面这些方法时，浏览器为了能返回正确的数据，会立即触发重排：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetTop, offsetLeft, offsetWidth, offsetHeight;</span><br><span class="line">scrollTop, scrollLeft, scrollWidth, scrollHeight;</span><br><span class="line">clientTop, clientLift, clientWidth, clientHeight;</span><br><span class="line">getComputedStyle();</span><br></pre></td></tr></table></figure><h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><p>考虑这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>);</span><br><span class="line">el.style.borderLeft = <span class="string">"1px"</span>;</span><br><span class="line">el.style.borderRight = <span class="string">"2px"</span>;</span><br><span class="line">el.style.margin = <span class="string">"3px"</span>;</span><br></pre></td></tr></table></figure><p>一般情况下，浏览器会优化这个，只发生一次重排。但是，如果在这期间有其他代码请求布局信息，会导致浏览器三次重排。一个更高效的方法就是，使用 cssText，只修改一次 DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>);</span><br><span class="line">el.style.cssText += <span class="string">"border-left:1px;border-right:2px;margin:3px;"</span>;</span><br></pre></td></tr></table></figure><p>另一个方法是修改元素的 class 名称，这种方法更清晰，更易维护，但是会带来轻微的性能影响，因为改变类时需要检查及联样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>);</span><br><span class="line">el.className = <span class="string">"active"</span>;</span><br></pre></td></tr></table></figure><h3 id="批量修改-DOM"><a href="#批量修改-DOM" class="headerlink" title="批量修改 DOM"></a>批量修改 DOM</h3><p>当需要对 DOM 元素进行一连串的操作时，可以先让元素脱离文档流，然后对其应用多重改变，再把元素加入文档流。第一步和第三步会触发两次重排，如果不这么做，第二步做的任何修改都会触发一次重排。</p><p>那么怎么才能让元素脱离文档流哪？ 有三种基本方法：</p><ol><li>隐藏元素，应用修改，重新显示</li><li>使用文档片段 (document fragment) 在当前 DOM 之外构建一个子树，再把它拷贝回文档</li><li>创建一个需要修改节点的镜像，然后修改镜像，再用镜像替换原节点</li></ol><p>比如我们需要向列表中添加一些项，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;test&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href&#x3D;&quot;url1&quot;&gt;Name1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href&#x3D;&quot;url2&quot;&gt;Name2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">var data &#x3D; [</span><br><span class="line">    &#123;url: &quot;url1&quot;, name: &quot;Name1&quot;&#125;,</span><br><span class="line">    &#123;url: &quot;url2&quot;, name: &quot;Name2&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们写一个添加的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDataToElement</span>(<span class="params">to, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> link, li, item;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">    item = data[i];</span><br><span class="line">    link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">    link.href = item.url;</span><br><span class="line">    link.appendChild(<span class="built_in">document</span>.createTextNode(item.name));</span><br><span class="line">    li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.appendChild(link);</span><br><span class="line">    to.appendChild(li);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure><p>如果使用这种方法， data 数组中的每一个新条目被增加到 DOM 树中都会导致重绘，我们可以此用第一种方法，改变需要重排元素的 display 属性，从而使其脱离文档流，添加完成后，在修改 display 属性，使其添加回文档流中，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line">ul.style.display = <span class="string">"none"</span>;</span><br><span class="line">appendDataToElementById(ul, data);</span><br><span class="line">ul.style.display = <span class="string">"block"</span>;</span><br></pre></td></tr></table></figure><p>第二种减少重排的方法就是使用文档片段，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure><p>第三种方式，需要为原节点创建一个镜像，添加完成后，再替换原来的 DOM 节点，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">var</span> cloneUl = ul.cloneNode(<span class="literal">true</span>);</span><br><span class="line">appendDataToElement(cloneUl, data);</span><br><span class="line">ul.parentNode.replaceChild(cloneUl, ul);</span><br></pre></td></tr></table></figure><p>推荐使用第二种方案，它操作 DOM 的次数最少。</p><h3 id="缓存布局信息"><a href="#缓存布局信息" class="headerlink" title="缓存布局信息"></a>缓存布局信息</h3><p>我们在用定时器写动画的时候，经常会出现这种写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es = el.style;</span><br><span class="line">es.left = <span class="number">1</span> + el.offsetLeft + <span class="string">"px"</span>;</span><br><span class="line">es.top = <span class="number">1</span> + el.offsetTop + <span class="string">"px"</span>;</span><br></pre></td></tr></table></figure><p>前面说过，这种写法会使浏览器强制重排获取正确的属性值，每次 ＋ 1 都会触发重排，我们可以将移动信息做缓存，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es = el.style,</span><br><span class="line">  positionNum = el.offsetLeft;</span><br><span class="line">es.left = ++positionNum;</span><br></pre></td></tr></table></figure><p>这样，我们就避免了，多次重排!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器下载完页面中的组件后，会解析并生成两个内部数据结构－－DOM 树(表示页面结构)、渲染树(表示 DOM 节点如何显示)。每当 DOM 元素的几何属性发生变化时（宽高发生变化、内容改编、位置发生变化等等），浏览器就需要重新计算变化元素和受影响的其他元素的几何属性。浏览器会使渲染树中受影响的部分失效，并重新构建渲染树，这个过程叫重排。重排完成后，浏览器会根据渲染树，把受影响的部分重新绘制到屏幕上，这个过程叫重绘。&lt;/p&gt;
&lt;p&gt;重排和重绘都是相当消耗性能的操作，它们会导致 Web 页面 UI 反应迟钝。应当尽量减少重排和重绘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>事件委托</title>
    <link href="http://yoursite.com/2015/08/09/event-delegation/"/>
    <id>http://yoursite.com/2015/08/09/event-delegation/</id>
    <published>2015-08-09T00:00:00.000Z</published>
    <updated>2020-10-22T09:16:57.817Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会遇到给一堆元素绑定事件的情况，比如说给每个 li 中的 a 元素添加 onclik 事件，每一个 a 都要绑定多次事件处理器，这会影响页面性能，每绑定一个页面处理器都是有代价的，访问的 DOM 元素越多，应用程序就越慢。特别是事件绑定通常发生在 onload 时，此时对每一个富交互应用的网页来说都是一个拥堵的时刻。事件绑定占用了处理事件，而且，浏览器需要跟踪每个事件处理器，这也会占用更多的内存。</p><p>一种简单的 DOM 事件处理技术就是事件委托。</p><a id="more"></a><p>根据 DOM 标准，每个事件都要经历三个阶段</p><ol><li>捕获（IE 不支持）</li><li>到达目标</li><li>冒泡</li></ol><p>对事件委托来说，冒泡就够了，比如说我们想要给下面这段代码中每个 a 标签增加一个点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"links"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>item5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以把 onclick 事件绑定在 ul 元素上，然后通过 event.target 获得当前冒泡事件对象，再根据业务逻辑判断是否是目标元素的点击事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"links"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">  <span class="keyword">if</span> (target.nodeName !== <span class="string">"A"</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(target.nodeName + <span class="string">": "</span> + target.textContent);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (list.addEventListener) &#123;</span><br><span class="line">  list.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.attachEvent) &#123;</span><br><span class="line">  list.attachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  list[<span class="string">"onclick"</span>] = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码可以很好的运行，但是假如我们想要的不是 a 标签，而是 li 标签，尝试修改其中这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (target.nodeName !== <span class="string">"LI"</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>运行发现并没有得到想要的结果。如果把刚刚修改的那行代码去掉，再次执行，每次点击 li，还是弹出的 a 标签的信息。</p><p>我们这里解释下，因为 Event.target 指向的是事件处理程序当前正在处理的那个元素，事件在冒泡阶段经历的过程是 a &gt; li &gt; ul ，所以刚开始 Event.target 指向的就是 a，之后由于 li 上并没有注册事件处理程序，结果 click 事件就一路冒泡到了 ul 上了，搞明白这个后，咱们把程序修改下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"links"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> target = e.target || e.srcElement,</span><br><span class="line">    currentTarget = e.currentTarget; <span class="comment">//e.currentTarget 是指向绑定事件处理器的对象，这里就是 ul 元素</span></span><br><span class="line">  <span class="keyword">while</span> (target !== currentTarget) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.nodeName === <span class="string">"LI"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(target.nodeName + <span class="string">": "</span> + target.textContent);</span><br><span class="line">    &#125;</span><br><span class="line">    target = target.parentNode; <span class="comment">//如果不是目标元素，就让 target 等于父元素，再次检查</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (list.addEventListener) &#123;</span><br><span class="line">  list.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.attachEvent) &#123;</span><br><span class="line">  list.attachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  list[<span class="string">"onclick"</span>] = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次终于可以了，最后依照惯例，我们重构下，提取公共函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addHandler = <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attchEvent) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addHandler = <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        element.attchEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.addHandler(element, type, handler);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.removeEventListener) &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeHandler = <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.detachEvent) &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeHandler = <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">        element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.removeHandler(element, type, handler);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e || <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e.target || e.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.preventDefault) e.preventDefault();</span><br><span class="line">    <span class="keyword">else</span> event.returnValue = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.stopPropagation) e.stopPropagation();</span><br><span class="line">    <span class="keyword">else</span> e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件委托</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[DOM]&#125;</span>   </span>element  [事件绑定元素]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[String]&#125;</span>   </span>type     [绑定事件类型，不加on]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[String]&#125;</span>   </span>nodeName [需要触发的子元素]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>fn       [子元素事件函数]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;[Function]&#125;</span>            </span>[事件handler,用来注销事件]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> delegation = <span class="function"><span class="keyword">function</span> (<span class="params">element, type, nodeName, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = EventUtil.getEvent(e),</span><br><span class="line">      target = EventUtil.getTarget(event),</span><br><span class="line">      currentTarget = event.currentTarget || element;</span><br><span class="line"></span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (target !== currentTarget) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nodeName.toUpperCase() === target.nodeName) &#123;</span><br><span class="line">        fn(target);</span><br><span class="line">        EventUtil.stopPropagation(event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      target = target.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  EventUtil.addHandler(element, type, handler);</span><br><span class="line">  <span class="keyword">return</span> handler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用起来，直接调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">"#links"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = delegation(ul, <span class="string">"click"</span>, <span class="string">"li"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target.nodeName);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//EventUtil.removeHandler(ul, "click", handler)   //注销事件</span></span><br></pre></td></tr></table></figure><p>是不是看起来舒服多了那:-P</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常会遇到给一堆元素绑定事件的情况，比如说给每个 li 中的 a 元素添加 onclik 事件，每一个 a 都要绑定多次事件处理器，这会影响页面性能，每绑定一个页面处理器都是有代价的，访问的 DOM 元素越多，应用程序就越慢。特别是事件绑定通常发生在 onload 时，此时对每一个富交互应用的网页来说都是一个拥堵的时刻。事件绑定占用了处理事件，而且，浏览器需要跟踪每个事件处理器，这也会占用更多的内存。&lt;/p&gt;
&lt;p&gt;一种简单的 DOM 事件处理技术就是事件委托。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
</feed>
