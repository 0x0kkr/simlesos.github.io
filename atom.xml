<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悠扬若素</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-02T03:19:21.512Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML5新增元素介绍</title>
    <link href="http://yoursite.com/2015/11/01/new-tag-from-html5/"/>
    <id>http://yoursite.com/2015/11/01/new-tag-from-html5/</id>
    <published>2015-11-01T00:00:00.000Z</published>
    <updated>2020-07-02T03:19:21.512Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5 新增了一些元素为了用于更好的文档结构，使用这<br>些标签能让章节和标题特性更精确，使得文档大纲变的可预测，结构更 Semantic！</p><a id="more"></a><h3 id="section"><a href="#section" class="headerlink" title="section"></a>section</h3><p><code>section</code> 元素表示一般意义上的区域/章节，，比如内容中的一个专题，一般会与<code>h1</code>~<code>h6</code>等元素搭配使用，以标示文档层级。如果元素内容可以分为几个部分的话，应该使用 <code>article</code> 而不是 <code>section</code>。不要把 <code>section</code> 元素作为一个普通的容器来使用，这种情况下 <code>div</code> 元素比他更合适，特别是仅仅用作美化样式的情况下。通常来说 <code>section</code> 应该出现在文档的框架中。</p><h3 id="article"><a href="#article" class="headerlink" title="article"></a>article</h3><p><code>article</code> 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，它可能是论坛帖子、文章、博客、用户提交评论或者是其它的独立内容项目。当 <code>article</code> 元素嵌套使用时，则该元素代表与外层元素有关的文章，例如代表博客评论的 <code>article</code> 元素可嵌套在代表博客文章的 <code>article</code> 元素中。</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p><code>main</code> 元素呈现了文档 <code>body</code> 或应用的主体部分，这部分内容在文档中应该是独一无二的，在一个文档中不能出现一个以上的 <code>main</code>,不能是以下元素的继承 <code>article</code>,<code>aside</code>,<code>footer</code>,<code>header</code>,<code>nav</code>。</p><h3 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h3><p><code>aside</code> 元素代表与了一些与页面其他部分关联性不是那么大的内容，比如广告。</p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p><code>header</code> 代表了一组介绍性或者导航性质的辅助内容，可能包含标题元素，也可以包含其他元素，像 logo、分节头部、搜索表单等。<code>header</code> 不是分节元素，不会引入分节到大纲中。</p><h3 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h3><p><code>footer</code> 元素表示最近的一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节坐着、版权数据或者文档相关的链接信息。</p><h3 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h3><p><code>nav</code> 代表一个含有多个超链接的区域。</p><h3 id="figure"><a href="#figure" class="headerlink" title="figure"></a>figure</h3><p><code>figure</code> 代表一个独立的内容流，常与 <code>figcaption</code> 元素一起出现。</p><h3 id="figcaption"><a href="#figcaption" class="headerlink" title="figcaption"></a>figcaption</h3><p><code>figcaption</code> 用作 <code>figure</code> 的标题，类似于表格的 <code>caption</code> 元素。</p><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p><code>template</code> 元素是一种机制，允许包含加载页面时不渲染，但又可以随后通过 Javascript 实力化的客户端内容，就像我们这样做一样<code>script type=&quot;text/temple&quot;</code>。</p><h3 id="audio-amp-video"><a href="#audio-amp-video" class="headerlink" title="audio &amp; video"></a>audio &amp; video</h3><p><code>audio</code> 和 <code>video</code> 是多媒体元素，他们提供相对应的 API 用于开发者定制 UI，同时也提供了出发 UA 展示其默认控件的方式。</p><h3 id="embed"><a href="#embed" class="headerlink" title="embed"></a>embed</h3><p><code>embed</code> 元素表示一个插件，展用于插件内容。</p><h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><p><code>mark</code> 元素代表了一个文档中需要标记或者高亮的部分，比如说搜索引擎搜索后的关键词。不要为了语法高亮而去使用 mark，应该使用 <code>strong</code> 元素，<code>mark</code> 元素表示上下文的关联性。</p><h3 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h3><p><code>progress</code> 用来表示一个进度条,代表一个任务的完成进度。</p><h3 id="meter"><a href="#meter" class="headerlink" title="meter"></a>meter</h3><p><code>meter</code> 代表了一个度量，比如对磁盘空间的度量。</p><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p><code>time</code> 表示一个时间。有两个属性,datetime(一个有效的时间格式，表示具体时间),pubdate(一般用于文章发布时间，评论回复时间等)。</p><h3 id="ruby、rt、rp"><a href="#ruby、rt、rp" class="headerlink" title="ruby、rt、rp"></a>ruby、rt、rp</h3><p><code>ruby</code>、<code>rt</code>、<code>rp</code> 代表 Ruby 表达式。</p><h3 id="bdi"><a href="#bdi" class="headerlink" title="bdi"></a>bdi</h3><p><code>bdi</code> 代表了一段隔绝于周围元素的双向书写文本格式。</p><h3 id="wbr"><a href="#wbr" class="headerlink" title="wbr"></a>wbr</h3><p><code>bdi</code> 代表了可能断行的部分。</p><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p><code>canvas</code> 用于渲染动态位图。</p><h3 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h3><p><code>datalist</code> 与 input 的 list 属性共同使用，可以用于创建下拉选择框控件。</p><h3 id="keygen"><a href="#keygen" class="headerlink" title="keygen"></a>keygen</h3><p><code>keygen</code> 代表生成的密钥对。</p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p><code>output</code> 代表了一种输出内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5 新增了一些元素为了用于更好的文档结构，使用这&lt;br&gt;些标签能让章节和标题特性更精确，使得文档大纲变的可预测，结构更 Semantic！&lt;/p&gt;
    
    </summary>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>重排与重绘</title>
    <link href="http://yoursite.com/2015/09/01/repaints-and-reflows/"/>
    <id>http://yoursite.com/2015/09/01/repaints-and-reflows/</id>
    <published>2015-09-01T00:00:00.000Z</published>
    <updated>2020-07-02T03:19:21.512Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器下载完页面中的组件后，会解析并生成两个内部数据结构－－DOM 树(表示页面结构)、渲染树(表示 DOM 节点如何显示)。每当 DOM 元素的几何属性发生变化时（宽高发生变化、内容改编、位置发生变化等等），浏览器就需要重新计算变化元素和受影响的其他元素的几何属性。浏览器会使渲染树中受影响的部分失效，并重新构建渲染树，这个过程叫重排。重排完成后，浏览器会根据渲染树，把受影响的部分重新绘制到屏幕上，这个过程叫重绘。</p><p>重排和重绘都是相当消耗性能的操作，它们会导致 Web 页面 UI 反应迟钝。应当尽量减少重排和重绘。</p><a id="more"></a><h2 id="何时重排"><a href="#何时重排" class="headerlink" title="何时重排"></a>何时重排</h2><ol><li>页面渲染器初始化的时候</li><li>浏览器窗口发生尺寸变化时</li><li>删除或添加新的可见 DOM 元素</li><li>元素的位置改变</li><li>元素的盒子模型发生变化</li><li>元素内容发生变化（引起盒子模型发生变化）</li></ol><h2 id="减少重排和重绘"><a href="#减少重排和重绘" class="headerlink" title="减少重排和重绘"></a>减少重排和重绘</h2><p>每次重绘和重排都会产生大量消耗，我们在编码时应当避免。</p><h3 id="渲染树队列与刷新"><a href="#渲染树队列与刷新" class="headerlink" title="渲染树队列与刷新"></a>渲染树队列与刷新</h3><p>大多数浏览器都会优化这个队列，通过批量执行等方式来优化重排过程，然而你可能会不经意间强制要求浏览器放弃优化，立即执行队列并刷新。</p><p>调用下面这些方法时，浏览器为了能返回正确的数据，会立即触发重排：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetTop, offsetLeft, offsetWidth, offsetHeight;</span><br><span class="line">scrollTop, scrollLeft, scrollWidth, scrollHeight;</span><br><span class="line">clientTop, clientLift, clientWidth, clientHeight;</span><br><span class="line">getComputedStyle();</span><br></pre></td></tr></table></figure><h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><p>考虑这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>);</span><br><span class="line">el.style.borderLeft = <span class="string">"1px"</span>;</span><br><span class="line">el.style.borderRight = <span class="string">"2px"</span>;</span><br><span class="line">el.style.margin = <span class="string">"3px"</span>;</span><br></pre></td></tr></table></figure><p>一般情况下，浏览器会优化这个，只发生一次重排。但是，如果在这期间有其他代码请求布局信息，会导致浏览器三次重排。一个更高效的方法就是，使用 cssText，只修改一次 DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>);</span><br><span class="line">el.style.cssText += <span class="string">"border-left:1px;border-right:2px;margin:3px;"</span>;</span><br></pre></td></tr></table></figure><p>另一个方法是修改元素的 class 名称，这种方法更清晰，更易维护，但是会带来轻微的性能影响，因为改变类时需要检查及联样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>);</span><br><span class="line">el.className = <span class="string">"active"</span>;</span><br></pre></td></tr></table></figure><h3 id="批量修改-DOM"><a href="#批量修改-DOM" class="headerlink" title="批量修改 DOM"></a>批量修改 DOM</h3><p>当需要对 DOM 元素进行一连串的操作时，可以先让元素脱离文档流，然后对其应用多重改变，再把元素加入文档流。第一步和第三步会触发两次重排，如果不这么做，第二步做的任何修改都会触发一次重排。</p><p>那么怎么才能让元素脱离文档流哪？ 有三种基本方法：</p><ol><li>隐藏元素，应用修改，重新显示</li><li>使用文档片段 (document fragment) 在当前 DOM 之外构建一个子树，再把它拷贝回文档</li><li>创建一个需要修改节点的镜像，然后修改镜像，再用镜像替换原节点</li></ol><p>比如我们需要向列表中添加一些项，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;test&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href&#x3D;&quot;url1&quot;&gt;Name1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href&#x3D;&quot;url2&quot;&gt;Name2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">var data &#x3D; [</span><br><span class="line">    &#123;url: &quot;url1&quot;, name: &quot;Name1&quot;&#125;,</span><br><span class="line">    &#123;url: &quot;url2&quot;, name: &quot;Name2&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们写一个添加的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDataToElement</span>(<span class="params">to, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> link, li, item;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">    item = data[i];</span><br><span class="line">    link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">    link.href = item.url;</span><br><span class="line">    link.appendChild(<span class="built_in">document</span>.createTextNode(item.name));</span><br><span class="line">    li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.appendChild(link);</span><br><span class="line">    to.appendChild(li);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure><p>如果使用这种方法， data 数组中的每一个新条目被增加到 DOM 树中都会导致重绘，我们可以此用第一种方法，改变需要重排元素的 display 属性，从而使其脱离文档流，添加完成后，在修改 display 属性，使其添加回文档流中，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line">ul.style.display = <span class="string">"none"</span>;</span><br><span class="line">appendDataToElementById(ul, data);</span><br><span class="line">ul.style.display = <span class="string">"block"</span>;</span><br></pre></td></tr></table></figure><p>第二种减少重排的方法就是使用文档片段，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure><p>第三种方式，需要为原节点创建一个镜像，添加完成后，再替换原来的 DOM 节点，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">var</span> cloneUl = ul.cloneNode(<span class="literal">true</span>);</span><br><span class="line">appendDataToElement(cloneUl, data);</span><br><span class="line">ul.parentNode.replaceChild(cloneUl, ul);</span><br></pre></td></tr></table></figure><p>推荐使用第二种方案，它操作 DOM 的次数最少。</p><h3 id="缓存布局信息"><a href="#缓存布局信息" class="headerlink" title="缓存布局信息"></a>缓存布局信息</h3><p>我们在用定时器写动画的时候，经常会出现这种写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es = el.style;</span><br><span class="line">es.left = <span class="number">1</span> + el.offsetLeft + <span class="string">"px"</span>;</span><br><span class="line">es.top = <span class="number">1</span> + el.offsetTop + <span class="string">"px"</span>;</span><br></pre></td></tr></table></figure><p>前面说过，这种写法会使浏览器强制重排获取正确的属性值，每次 ＋ 1 都会触发重排，我们可以将移动信息做缓存，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es = el.style,</span><br><span class="line">  positionNum = el.offsetLeft;</span><br><span class="line">es.left = ++positionNum;</span><br></pre></td></tr></table></figure><p>这样，我们就避免了，多次重排!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器下载完页面中的组件后，会解析并生成两个内部数据结构－－DOM 树(表示页面结构)、渲染树(表示 DOM 节点如何显示)。每当 DOM 元素的几何属性发生变化时（宽高发生变化、内容改编、位置发生变化等等），浏览器就需要重新计算变化元素和受影响的其他元素的几何属性。浏览器会使渲染树中受影响的部分失效，并重新构建渲染树，这个过程叫重排。重排完成后，浏览器会根据渲染树，把受影响的部分重新绘制到屏幕上，这个过程叫重绘。&lt;/p&gt;
&lt;p&gt;重排和重绘都是相当消耗性能的操作，它们会导致 Web 页面 UI 反应迟钝。应当尽量减少重排和重绘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
</feed>
