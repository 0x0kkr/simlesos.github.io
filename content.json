{"pages":[{"title":"About me","text":"目前就职于国内某教育公司前端工程师职位。 技术经历： 15 到 17 年， C#/ASP.NET 后端开发，开始接触 Windows Phone，转型做 WP 和 Win8 应用开发，后续随着 WP 和 Windows8 的没落，放弃微软系 17 年开始接触 Android 开发，自学并独立上线应用 17 年底接触前端开发，裸辞自学两个月 18 年初全职做前端开发至今，期间做过 PC/H5，RN，Egret(白鹭引擎)，小程序… 技术栈： JS/TS/NodeJS/React/Vue/Flutter/Swift/MP(小程序) 联系我","link":"/about/index.html"}],"posts":[{"title":"HTML5新增元素介绍","text":"HTML5 新增了一些元素为了用于更好的文档结构，使用这些标签能让章节和标题特性更精确，使得文档大纲变的可预测，结构更 Semantic！ sectionsection 元素表示一般意义上的区域/章节，，比如内容中的一个专题，一般会与h1~h6等元素搭配使用，以标示文档层级。如果元素内容可以分为几个部分的话，应该使用 article 而不是 section。不要把 section 元素作为一个普通的容器来使用，这种情况下 div 元素比他更合适，特别是仅仅用作美化样式的情况下。通常来说 section 应该出现在文档的框架中。 articlearticle 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，它可能是论坛帖子、文章、博客、用户提交评论或者是其它的独立内容项目。当 article 元素嵌套使用时，则该元素代表与外层元素有关的文章，例如代表博客评论的 article 元素可嵌套在代表博客文章的 article 元素中。 mainmain 元素呈现了文档 body 或应用的主体部分，这部分内容在文档中应该是独一无二的，在一个文档中不能出现一个以上的 main,不能是以下元素的继承 article,aside,footer,header,nav。 asideaside 元素代表与了一些与页面其他部分关联性不是那么大的内容，比如广告。 headerheader 代表了一组介绍性或者导航性质的辅助内容，可能包含标题元素，也可以包含其他元素，像 logo、分节头部、搜索表单等。header 不是分节元素，不会引入分节到大纲中。 footerfooter 元素表示最近的一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节坐着、版权数据或者文档相关的链接信息。 navnav 代表一个含有多个超链接的区域。 figurefigure 代表一个独立的内容流，常与 figcaption 元素一起出现。 figcaptionfigcaption 用作 figure 的标题，类似于表格的 caption 元素。 templatetemplate 元素是一种机制，允许包含加载页面时不渲染，但又可以随后通过 Javascript 实力化的客户端内容，就像我们这样做一样script type=&quot;text/temple&quot;。 audio &amp; videoaudio 和 video 是多媒体元素，他们提供相对应的 API 用于开发者定制 UI，同时也提供了出发 UA 展示其默认控件的方式。 embedembed 元素表示一个插件，展用于插件内容。 markmark 元素代表了一个文档中需要标记或者高亮的部分，比如说搜索引擎搜索后的关键词。不要为了语法高亮而去使用 mark，应该使用 strong 元素，mark 元素表示上下文的关联性。 progressprogress 用来表示一个进度条,代表一个任务的完成进度。 metermeter 代表了一个度量，比如对磁盘空间的度量。 timetime 表示一个时间。有两个属性,datetime(一个有效的时间格式，表示具体时间),pubdate(一般用于文章发布时间，评论回复时间等)。 ruby、rt、rpruby、rt、rp 代表 Ruby 表达式。 bdibdi 代表了一段隔绝于周围元素的双向书写文本格式。 wbrbdi 代表了可能断行的部分。 canvascanvas 用于渲染动态位图。 datalistdatalist 与 input 的 list 属性共同使用，可以用于创建下拉选择框控件。 keygenkeygen 代表生成的密钥对。 outputoutput 代表了一种输出内容。","link":"/2015/11/01/new-tag-from-html5/"},{"title":"重排与重绘","text":"浏览器下载完页面中的组件后，会解析并生成两个内部数据结构－－DOM 树(表示页面结构)、渲染树(表示 DOM 节点如何显示)。每当 DOM 元素的几何属性发生变化时（宽高发生变化、内容改编、位置发生变化等等），浏览器就需要重新计算变化元素和受影响的其他元素的几何属性。浏览器会使渲染树中受影响的部分失效，并重新构建渲染树，这个过程叫重排。重排完成后，浏览器会根据渲染树，把受影响的部分重新绘制到屏幕上，这个过程叫重绘。 重排和重绘都是相当消耗性能的操作，它们会导致 Web 页面 UI 反应迟钝。应当尽量减少重排和重绘。 何时重排 页面渲染器初始化的时候 浏览器窗口发生尺寸变化时 删除或添加新的可见 DOM 元素 元素的位置改变 元素的盒子模型发生变化 元素内容发生变化（引起盒子模型发生变化） 减少重排和重绘每次重绘和重排都会产生大量消耗，我们在编码时应当避免。 渲染树队列与刷新大多数浏览器都会优化这个队列，通过批量执行等方式来优化重排过程，然而你可能会不经意间强制要求浏览器放弃优化，立即执行队列并刷新。 调用下面这些方法时，浏览器为了能返回正确的数据，会立即触发重排： 1234offsetTop, offsetLeft, offsetWidth, offsetHeight;scrollTop, scrollLeft, scrollWidth, scrollHeight;clientTop, clientLift, clientWidth, clientHeight;getComputedStyle(); 优化代码考虑这个例子： 1234var el = document.getElementById(\"header\");el.style.borderLeft = \"1px\";el.style.borderRight = \"2px\";el.style.margin = \"3px\"; 一般情况下，浏览器会优化这个，只发生一次重排。但是，如果在这期间有其他代码请求布局信息，会导致浏览器三次重排。一个更高效的方法就是，使用 cssText，只修改一次 DOM： 12var el = document.getElementById(\"header\");el.style.cssText += \"border-left:1px;border-right:2px;margin:3px;\"; 另一个方法是修改元素的 class 名称，这种方法更清晰，更易维护，但是会带来轻微的性能影响，因为改变类时需要检查及联样式。 12var el = document.getElementById(\"header\");el.className = \"active\"; 批量修改 DOM当需要对 DOM 元素进行一连串的操作时，可以先让元素脱离文档流，然后对其应用多重改变，再把元素加入文档流。第一步和第三步会触发两次重排，如果不这么做，第二步做的任何修改都会触发一次重排。 那么怎么才能让元素脱离文档流哪？ 有三种基本方法： 隐藏元素，应用修改，重新显示 使用文档片段 (document fragment) 在当前 DOM 之外构建一个子树，再把它拷贝回文档 创建一个需要修改节点的镜像，然后修改镜像，再用镜像替换原节点 比如我们需要向列表中添加一些项，如下 12345678&lt;ul id=&quot;test&quot;&gt; &lt;li&gt;&lt;a href=&quot;url1&quot;&gt;Name1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;url2&quot;&gt;Name2&lt;/a&gt;&lt;/li&gt;&lt;ul&gt;var data = [ {url: &quot;url1&quot;, name: &quot;Name1&quot;}, {url: &quot;url2&quot;, name: &quot;Name2&quot;}] 我们写一个添加的函数 123456789101112131415function appendDataToElement(to, data) { var link, li, item; for (var i = 0, len = data.length; i &lt; len; i++) { item = data[i]; link = document.createElement(\"a\"); link.href = item.url; link.appendChild(document.createTextNode(item.name)); li = document.createElement(\"li\"); li.appendChild(link); to.appendChild(li); }}var ul = document.getElementById(\"test\");appendDataToElement(ul, data); 如果使用这种方法， data 数组中的每一个新条目被增加到 DOM 树中都会导致重绘，我们可以此用第一种方法，改变需要重排元素的 display 属性，从而使其脱离文档流，添加完成后，在修改 display 属性，使其添加回文档流中，代码如下： 1234var ul = document.getElementById(\"test\");ul.style.display = \"none\";appendDataToElementById(ul, data);ul.style.display = \"block\"; 第二种减少重排的方法就是使用文档片段，代码如下： 1234var fragment = document.createDocumentFragment();appendDataToElement(fragment, data);var ul = document.getElementById(\"test\");ul.appendChild(fragment); 第三种方式，需要为原节点创建一个镜像，添加完成后，再替换原来的 DOM 节点，代码如下： 1234var ul = document.getElementById(\"test\");var cloneUl = ul.cloneNode(true);appendDataToElement(cloneUl, data);ul.parentNode.replaceChild(cloneUl, ul); 推荐使用第二种方案，它操作 DOM 的次数最少。 缓存布局信息我们在用定时器写动画的时候，经常会出现这种写法： 123var es = el.style;es.left = 1 + el.offsetLeft + \"px\";es.top = 1 + el.offsetTop + \"px\"; 前面说过，这种写法会使浏览器强制重排获取正确的属性值，每次 ＋ 1 都会触发重排，我们可以将移动信息做缓存，如下 123var es = el.style, positionNum = el.offsetLeft;es.left = ++positionNum; 这样，我们就避免了，多次重排!","link":"/2015/09/01/repaints-and-reflows/"}],"tags":[{"name":"DOM","slug":"DOM","link":"/tags/DOM/"}],"categories":[{"name":"FrontEnd","slug":"FrontEnd","link":"/categories/FrontEnd/"}]}