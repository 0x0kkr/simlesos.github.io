{"pages":[{"title":"About me","text":"目前就职于国内某教育公司前端工程师职位。 技术经历： 15 到 17 年， C#/ASP.NET 后端开发，开始接触 Windows Phone，转型做 WP 和 Win8 应用开发，后续随着 WP 和 Windows8 的没落，放弃微软系 17 年开始接触 Android 开发，自学并独立上线应用 17 年底接触前端开发，裸辞自学两个月 18 年初全职做前端开发至今，期间做过 PC/H5，RN，Egret(白鹭引擎)，小程序… 技术栈： JS/TS/NodeJS/React/Vue/Flutter/Swift/MP(小程序) 联系我","link":"/about/index.html"}],"posts":[{"title":"JS模块化","text":"在 ES6 之前的 js 中，并没有像 java 的 import，C# 的 using，css 的 @import 这种类似的语言支持的模块系统。 模块是什么?模块要实现的基本功能包块下面三点: 封装实现 暴漏接口 依赖声明 早期的无模块我们一步一步来看,最早期的时候,假如有这么一段代码: 12345678910//a.jsfunction random(number) { return Math.floor(Math.random() * number);}//b.jsvar _max = 10; //直接暴漏私有变量function getNumber() { return random(_max + 1);} 这段代码中，b.js 依赖 a.js，但是却没有显式的依赖关系，完全凭程序员的自觉，并且两个 js 文件中的函数都是暴漏在全局环境中。显然这并不能满足我们的需求。 对象字面量包装我们对上面的代码稍作改进 1234567891011121314151617181920//a.jsvar a = function(){ function random(number){ return Math.floor(Math.random() * number); } return { random: random }}//b.jsvar b = function(){ var _max = 10; function getNumber(){ return random(_max + 1); } return { getNumber: getNumber; }} 这样看起来代码更具有结构性，b.js 中得私有变量 _max 也成功的被隔离在闭包中，成为私有成员，外界无法访问。并且每个 js 文件只暴漏了一个全局变量。这种模式在 javascript 中被称为模块暴漏。看起来这段代码似乎改善了一些问题，但是这远远没有达到我们的需求，依赖声明问题依然没有解决。 IIFE我们需要一个显式的依赖声明，可以通过 IIFE(Immediately Invoked Function Expression)，函数被包含在一对()内，就成为一个表达式，通过在末尾加上另一个 () 就可以立即执行这个函数，这就是 立即执行函数表达式，我们将上面的代码改成这种来看看 1234567891011121314151617181920//a.jsvar a = (function(){ function random(number){ return Math.floor(Math.random() * number); } return { random: random }})();//b.jsvar b = (function(a){ var _max = 10; function getNumber(){ return a.random(_max + 1); } return { getNumber: getNumber; }})(a); 这里我们通过 IIFE 将 a.js 和 b.js 包裹在一个闭包中，我们不需要再去额外的调用 a，b 函数来获取暴漏接口，并在 b.js 中显式的声明了依赖关系，但是依然没有依赖控制，仍然污染了全局变量。 命名空间式的模块我们可以定义一个模块加载器，核心代码如下: 12345678910111213141516var MyModules = (function Manager() { var modules = {}; function define(name, deps, impl) { for (var i = 0; i &lt; deps.length; i++) { deps[i] = modules[deps[i]]; } modules[name] = impl.apply(impl, deps); } function get(name) { return modules[name]; } return { define: define, get: get, };})(); 我们把所有模块都存放在 modules 列表中，并且统一管理依赖关系，使用起来如下: 123456789101112131415161718192021MyModules.defined(\"a\", [], function () { function random(number) { return Math.floor(Math.random() * number); } return { random: random, };});MyModules.defined(\"b\", [\"a\"], function (a) { var _max = 10; function getNumber() { return a.random(_max + 1); } return { getNumber: getNumber, };});var b = MyModules.get(\"b\");b.getNumber(); //=&gt; some number 熟悉 AMD 的朋友看起来一定不会陌生。这种命名空间的方式显式声明了依赖关系，并且完全消除了对全局环境的污染，但是依赖管理上还是有问题，如果 a， b 模块定义在不同 js 文件中，那么还是需要人为的去控制 a.js 和 b.js 的引用顺序，简单的还好说，如果有十几个复杂的依赖关系，组成一条依赖链，人力根本无法处理如此复杂的关系网 模块系统模块系统最重要的功能就是依赖管理，包含了 加载、分析、注入、初始化这四个最主要的功能，同时不同的模块系统有着不同的模块写法。 CommonJSCommonJS 主要被用作非浏览器环境中的模块化，但是通过 browserify 或者 webpack 也可以在浏览器中使用。 大名鼎鼎的 node.js 中的模块化就使用的 CommonJS。 举个栗子: 12345678910111213//a.jsfunction random(number) { return Math.floor(Math.random() * number);}exports.random = random;//b.jsvar a = require(\"/a\"); // 依赖声明var _max = 10;function getNumber() { return a.random(_max + 1);}exports.getNumber = getNumber; CommonJS 社区活跃度很高，规范接受度也非常高，是运行时支持的，作用域基于文件，一个文件就是一个模块。但是因为使用了同步的 require，没有考虑浏览器环境，在浏览器下无法直接使用。 优点:依赖管理成熟可靠社区活跃,规范接受度高运行时支持,模块定义非常简单文件级的模块作用域隔离缺点:不是标准组织的规范同步 require,没有考虑浏览器环境 AMD由于 CommonJS 没有考虑异步使用情况，于是就有了 AMD(Asynchronous Module Definition) 规范。比较有名的就是 requireJS，AMD 使用起来和我们上面所讲的命名空间型的模块定义及其相似 12345678910111213141516//a.jsdefine([], function () { function random(number) { return Math.floor(Math.random() * number); } return { random: random };});//b.jsdefine([\"/a\"], function (a) { var _max = 10; function getNumber() { return a.random(_max + 1); } return { getNumber: getNumber };}); 虽然写法上很相似,但是区区十几行的命名空间模块显然无法和 AMD 相提并论， 最大的区别就是依赖管理。 另外 AMD 还有种 Simplified CommonJS wrapping 的写法，可以和 CommonJS 的写法很相似 12345678define(function (require, exports) { var a = require(\"./a\"); var _max = 10; function getNumber() { return a.random(_max + 1); } exports.getNumber = getNumber;}); 这种写法其实还是依赖前置(通过正则匹配等方式)，并不是类似于 Seajs 的 CMD 那样依赖后置，只是写法上的类似。 优点:依赖管理成熟可靠社区活跃,规范接受度高专为异步 IO 环境打造,适合浏览器环境支持类似 Commonjs 的书写方式通过 load plug 可以支持加载非 js 资源成熟的打包工具,并可结合插件使用缺点:模块定义繁琐,需要额外嵌套只是库级别的支持,需要引入额外库无法处理循环依赖无法实现条件加载 JS 语言级别的模块化新的 ES 规范中,出现了 JS 语言级别的模块化: 1234567891011//a.jsexport default random(number){ return Math.floor(Math.random() * number);}//b.jsimport a from 'a';var _max = 10;export default function getNumber(){ return a.random(_max + 1);} 优点:真正的规范,模块化的标准语言级别的关键字支持适应所有 javascript 运行时,包括浏览器支持循环依赖缺点:规范未达到稳定级别基本还没有浏览器支持 总结我们首先引入了 IIFE，然后加入了命名空间，但是核心的依赖分析和注入没有实现，于是出现了 AMD， Commonjs， ES6 这些新秀，他们之间也可以通过一些库来实现相互转换，比如 system.js，按需使用。 模块化使得 js 具备开发大型应用的能力，而不是停留在小脚本程序的阶段，当然也离不开标准的制定。","link":"/2015/04/09/es-module/"},{"title":"事件委托","text":"我们经常会遇到给一堆元素绑定事件的情况，比如说给每个 li 中的 a 元素添加 onclik 事件，每一个 a 都要绑定多次事件处理器，这会影响页面性能，每绑定一个页面处理器都是有代价的，访问的 DOM 元素越多，应用程序就越慢。特别是事件绑定通常发生在 onload 时，此时对每一个富交互应用的网页来说都是一个拥堵的时刻。事件绑定占用了处理事件，而且，浏览器需要跟踪每个事件处理器，这也会占用更多的内存。 一种简单的 DOM 事件处理技术就是事件委托。 根据 DOM 标准，每个事件都要经历三个阶段 捕获（IE 不支持） 到达目标 冒泡 对事件委托来说，冒泡就够了，比如说我们想要给下面这段代码中每个 a 标签增加一个点击事件 1234567&lt;ul id=\"links\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;item1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;item2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;item3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;item4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;item5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 可以把 onclick 事件绑定在 ul 元素上，然后通过 event.target 获得当前冒泡事件对象，再根据业务逻辑判断是否是目标元素的点击事件 123456789101112131415var list = document.getElementById(\"links\");var handler = function (e) { e = e || window.event; e.preventDefault(); var target = e.target || e.srcElement; if (target.nodeName !== \"A\") return; console.log(target.nodeName + \": \" + target.textContent);};if (list.addEventListener) { list.addEventListener(\"click\", handler, false);} else if (list.attachEvent) { list.attachEvent(\"onclick\", handler);} else { list[\"onclick\"] = handler;} 上面这段代码可以很好的运行，但是假如我们想要的不是 a 标签，而是 li 标签，尝试修改其中这段代码： 1if (target.nodeName !== \"LI\") return; 运行发现并没有得到想要的结果。如果把刚刚修改的那行代码去掉，再次执行，每次点击 li，还是弹出的 a 标签的信息。 我们这里解释下，因为 Event.target 指向的是事件处理程序当前正在处理的那个元素，事件在冒泡阶段经历的过程是 a &gt; li &gt; ul ，所以刚开始 Event.target 指向的就是 a，之后由于 li 上并没有注册事件处理程序，结果 click 事件就一路冒泡到了 ul 上了，搞明白这个后，咱们把程序修改下： 1234567891011121314151617181920var list = document.getElementById(\"links\");var handler = function (e) { e = e || window.event; e.preventDefault(); var target = e.target || e.srcElement, currentTarget = e.currentTarget; //e.currentTarget 是指向绑定事件处理器的对象，这里就是 ul 元素 while (target !== currentTarget) { if (target.nodeName === \"LI\") { console.log(target.nodeName + \": \" + target.textContent); } target = target.parentNode; //如果不是目标元素，就让 target 等于父元素，再次检查 }};if (list.addEventListener) { list.addEventListener(\"click\", handler, false);} else if (list.attachEvent) { list.attachEvent(\"onclick\", handler);} else { list[\"onclick\"] = handler;} 这次终于可以了，最后依照惯例，我们重构下，提取公共函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var EventUtil = { addHandler: function (element, type, handler) { if (window.addEventListener) { this.addHandler = function (element, type, handler) { element.addEventListener(type, handler, false); }; } else if (window.attchEvent) { this.addHandler = function (element, type, handler) { element.attchEvent(\"on\" + type, handler); }; } this.addHandler(element, type, handler); }, removeHandler: function (element, type, handler) { if (window.removeEventListener) { this.removeHandler = function (element, type, handler) { element.removeEventListener(type, handler, false); }; } else if (window.detachEvent) { this.removeHandler = function (element, type, handler) { element.detachEvent(\"on\" + type, handler); }; } this.removeHandler(element, type, handler); }, getEvent: function (e) { return e || window.event; }, getTarget: function (e) { return e.target || e.srcElement; }, preventDefault: function (e) { if (e.preventDefault) e.preventDefault(); else event.returnValue = false; }, stopPropagation: function (e) { if (e.stopPropagation) e.stopPropagation(); else e.cancelBubble = true; },};/** * 事件委托 * @param {[DOM]} element [事件绑定元素] * @param {[String]} type [绑定事件类型，不加on] * @param {[String]} nodeName [需要触发的子元素] * @param {Function} fn [子元素事件函数] * @return {[Function]} [事件handler,用来注销事件] */var delegation = function (element, type, nodeName, fn) { var handler = function (e) { var event = EventUtil.getEvent(e), target = EventUtil.getTarget(event), currentTarget = event.currentTarget || element; EventUtil.preventDefault(event); while (target !== currentTarget) { if (nodeName.toUpperCase() === target.nodeName) { fn(target); EventUtil.stopPropagation(event); break; } target = target.parentNode; } }; EventUtil.addHandler(element, type, handler); return handler;}; 使用起来，直接调用 123456var ul = document.querySelector(\"#links\");var handler = delegation(ul, \"click\", \"li\", function (target) { console.log(target.nodeName);});//EventUtil.removeHandler(ul, \"click\", handler) //注销事件 是不是看起来舒服多了那:-P","link":"/2015/08/09/event-delegation/"},{"title":"JS基于时间的动画","text":"说起前端动画,不得不提 CSS 动画和 JS 动画,这里简单谈谈这两者. CSS 动画简单方便,在样式表中就可以管理动画的内容,但相应的可维护性也随之降低;对动画的控制能力不足,比如说拖拽动画等等无法实现;放弃了物理动效的支持,只能通过缓动函数来模拟.相比之 JS 动画则依托完备的编程语言,可以对动效的设计进行无限的控制,虽然编写起来相比 CSS 动画来说较为复杂,但可以通过一些第三方库来快速实现,比如 VelocityJS . 当然,事物的好坏永远需要按场景区分, CSS 动画和 JS 动画也是如此,比如说一个简单的按钮 hover 效果,无论怎么看 CSS 动画都是第一选择,但是如果需要控制一个动画工作流,那 JS 动画一定更适合了. 有点跑题了…, 回到正文 关键帧动画假如现在我们有这样一个需求 让一个 div 向右边移动 300px 的距离，我们来看看下面这种实现： 看起来我们实现了这个需求，不过不要急,我们稍稍修改上面代码中的 step 函数,在其中加入这段代码: 1234if (left == 200) { var start = +new Date(); while (+new Date() - start &lt; 1000) {} //阻塞1s} 大家可以去 jsfiddle 中加入这段代码，观察后，不难发现这个 div 在 left 值为 200px 的地方停顿了 1000+ms。大家都知道 js 是基于事件模型的，我们在 step 函数中 setInterval 其实相当于告诉引擎,帮我在 16.7 毫秒后将这个回调函数加入事件队列,如果引擎空闲就执行,此时我们 while 循环 1 秒，就会阻塞整个事件队列的运行，也就阻塞了 UI 线程的渲染，表现出来结果就是我们的 div 运动停止了 1 秒多。 这里虽然是人为的加入了阻塞代码，但是在正常的开发过程中，setInterval 和 setTimeout 根本没法保证按我们要求的在固定的间隔执行事件，此时如果我们的动画还是按照 变化量/帧 的方式来执行，就会出现不同设备中动画执行时间不同的情况,在移动端是重灾区。 基于时间的动画在讨论上面所述的问题该如何解决之前，不妨先来看看这个数学题: A 地和 B 地相距 300m，一辆速度为 5m/s 匀速运动的自行车从 A 地出发去往 B 地,请问一分钟后自行车距离 A 地多远? 我们用时间 时间 _ 速度 即可得出 5 _ 60 = 300,也就是 300m，从这个简单的问题中，我们可以发现我们不必去寄人篱下一帧帧的做动效，不必去管帧率的问题,我们可以从动画开始时间到当前时间计算出动画经过的时间，通过 时间 * 速度，计算出当前动画的偏移量，这样就可以保证我们所有性能的平台下动画都是一个速度进行着。下面我们来修改下上面的代码: 这里我们改为根据时间来计算偏移量，我的测试环境中弹出的结果应该在 4801，下面我们来看看加入同样阻塞代码后的用时，是不是也增加了 1000 毫秒那: 我的测试环境弹出的是 4865，可以看出虽然加入了阻塞代码，但是因为我们是按照时间来计算偏移量的，所以动画总时间不会偏差过大，各个平台下动画也不会出现有的快有的慢得情况。 总结基于时间的动效能够消除不同设备不同环境下动画帧数不同导致的动效速度不同的问题，推荐所有的动效都应该采用基于时间的方式!","link":"/2016/01/01/js-animation/"},{"title":"HTML5新增元素介绍","text":"HTML5 新增了一些元素为了用于更好的文档结构，使用这些标签能让章节和标题特性更精确，使得文档大纲变的可预测，结构更 Semantic！ sectionsection 元素表示一般意义上的区域/章节，，比如内容中的一个专题，一般会与h1~h6等元素搭配使用，以标示文档层级。如果元素内容可以分为几个部分的话，应该使用 article 而不是 section。不要把 section 元素作为一个普通的容器来使用，这种情况下 div 元素比他更合适，特别是仅仅用作美化样式的情况下。通常来说 section 应该出现在文档的框架中。 articlearticle 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，它可能是论坛帖子、文章、博客、用户提交评论或者是其它的独立内容项目。当 article 元素嵌套使用时，则该元素代表与外层元素有关的文章，例如代表博客评论的 article 元素可嵌套在代表博客文章的 article 元素中。 mainmain 元素呈现了文档 body 或应用的主体部分，这部分内容在文档中应该是独一无二的，在一个文档中不能出现一个以上的 main,不能是以下元素的继承 article,aside,footer,header,nav。 asideaside 元素代表与了一些与页面其他部分关联性不是那么大的内容，比如广告。 headerheader 代表了一组介绍性或者导航性质的辅助内容，可能包含标题元素，也可以包含其他元素，像 logo、分节头部、搜索表单等。header 不是分节元素，不会引入分节到大纲中。 footerfooter 元素表示最近的一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节坐着、版权数据或者文档相关的链接信息。 navnav 代表一个含有多个超链接的区域。 figurefigure 代表一个独立的内容流，常与 figcaption 元素一起出现。 figcaptionfigcaption 用作 figure 的标题，类似于表格的 caption 元素。 templatetemplate 元素是一种机制，允许包含加载页面时不渲染，但又可以随后通过 Javascript 实力化的客户端内容，就像我们这样做一样script type=&quot;text/temple&quot;。 audio &amp; videoaudio 和 video 是多媒体元素，他们提供相对应的 API 用于开发者定制 UI，同时也提供了出发 UA 展示其默认控件的方式。 embedembed 元素表示一个插件，展用于插件内容。 markmark 元素代表了一个文档中需要标记或者高亮的部分，比如说搜索引擎搜索后的关键词。不要为了语法高亮而去使用 mark，应该使用 strong 元素，mark 元素表示上下文的关联性。 progressprogress 用来表示一个进度条,代表一个任务的完成进度。 metermeter 代表了一个度量，比如对磁盘空间的度量。 timetime 表示一个时间。有两个属性,datetime(一个有效的时间格式，表示具体时间),pubdate(一般用于文章发布时间，评论回复时间等)。 ruby、rt、rpruby、rt、rp 代表 Ruby 表达式。 bdibdi 代表了一段隔绝于周围元素的双向书写文本格式。 wbrbdi 代表了可能断行的部分。 canvascanvas 用于渲染动态位图。 datalistdatalist 与 input 的 list 属性共同使用，可以用于创建下拉选择框控件。 keygenkeygen 代表生成的密钥对。 outputoutput 代表了一种输出内容。","link":"/2015/11/01/new-tag-from-html5/"},{"title":"重排与重绘","text":"浏览器下载完页面中的组件后，会解析并生成两个内部数据结构－－DOM 树(表示页面结构)、渲染树(表示 DOM 节点如何显示)。每当 DOM 元素的几何属性发生变化时（宽高发生变化、内容改编、位置发生变化等等），浏览器就需要重新计算变化元素和受影响的其他元素的几何属性。浏览器会使渲染树中受影响的部分失效，并重新构建渲染树，这个过程叫重排。重排完成后，浏览器会根据渲染树，把受影响的部分重新绘制到屏幕上，这个过程叫重绘。 重排和重绘都是相当消耗性能的操作，它们会导致 Web 页面 UI 反应迟钝。应当尽量减少重排和重绘。 何时重排 页面渲染器初始化的时候 浏览器窗口发生尺寸变化时 删除或添加新的可见 DOM 元素 元素的位置改变 元素的盒子模型发生变化 元素内容发生变化（引起盒子模型发生变化） 减少重排和重绘每次重绘和重排都会产生大量消耗，我们在编码时应当避免。 渲染树队列与刷新大多数浏览器都会优化这个队列，通过批量执行等方式来优化重排过程，然而你可能会不经意间强制要求浏览器放弃优化，立即执行队列并刷新。 调用下面这些方法时，浏览器为了能返回正确的数据，会立即触发重排： 1234offsetTop, offsetLeft, offsetWidth, offsetHeight;scrollTop, scrollLeft, scrollWidth, scrollHeight;clientTop, clientLift, clientWidth, clientHeight;getComputedStyle(); 优化代码考虑这个例子： 1234var el = document.getElementById(\"header\");el.style.borderLeft = \"1px\";el.style.borderRight = \"2px\";el.style.margin = \"3px\"; 一般情况下，浏览器会优化这个，只发生一次重排。但是，如果在这期间有其他代码请求布局信息，会导致浏览器三次重排。一个更高效的方法就是，使用 cssText，只修改一次 DOM： 12var el = document.getElementById(\"header\");el.style.cssText += \"border-left:1px;border-right:2px;margin:3px;\"; 另一个方法是修改元素的 class 名称，这种方法更清晰，更易维护，但是会带来轻微的性能影响，因为改变类时需要检查及联样式。 12var el = document.getElementById(\"header\");el.className = \"active\"; 批量修改 DOM当需要对 DOM 元素进行一连串的操作时，可以先让元素脱离文档流，然后对其应用多重改变，再把元素加入文档流。第一步和第三步会触发两次重排，如果不这么做，第二步做的任何修改都会触发一次重排。 那么怎么才能让元素脱离文档流哪？ 有三种基本方法： 隐藏元素，应用修改，重新显示 使用文档片段 (document fragment) 在当前 DOM 之外构建一个子树，再把它拷贝回文档 创建一个需要修改节点的镜像，然后修改镜像，再用镜像替换原节点 比如我们需要向列表中添加一些项，如下 12345678&lt;ul id=&quot;test&quot;&gt; &lt;li&gt;&lt;a href=&quot;url1&quot;&gt;Name1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;url2&quot;&gt;Name2&lt;/a&gt;&lt;/li&gt;&lt;ul&gt;var data = [ {url: &quot;url1&quot;, name: &quot;Name1&quot;}, {url: &quot;url2&quot;, name: &quot;Name2&quot;}] 我们写一个添加的函数 123456789101112131415function appendDataToElement(to, data) { var link, li, item; for (var i = 0, len = data.length; i &lt; len; i++) { item = data[i]; link = document.createElement(\"a\"); link.href = item.url; link.appendChild(document.createTextNode(item.name)); li = document.createElement(\"li\"); li.appendChild(link); to.appendChild(li); }}var ul = document.getElementById(\"test\");appendDataToElement(ul, data); 如果使用这种方法， data 数组中的每一个新条目被增加到 DOM 树中都会导致重绘，我们可以此用第一种方法，改变需要重排元素的 display 属性，从而使其脱离文档流，添加完成后，在修改 display 属性，使其添加回文档流中，代码如下： 1234var ul = document.getElementById(\"test\");ul.style.display = \"none\";appendDataToElementById(ul, data);ul.style.display = \"block\"; 第二种减少重排的方法就是使用文档片段，代码如下： 1234var fragment = document.createDocumentFragment();appendDataToElement(fragment, data);var ul = document.getElementById(\"test\");ul.appendChild(fragment); 第三种方式，需要为原节点创建一个镜像，添加完成后，再替换原来的 DOM 节点，代码如下： 1234var ul = document.getElementById(\"test\");var cloneUl = ul.cloneNode(true);appendDataToElement(cloneUl, data);ul.parentNode.replaceChild(cloneUl, ul); 推荐使用第二种方案，它操作 DOM 的次数最少。 缓存布局信息我们在用定时器写动画的时候，经常会出现这种写法： 123var es = el.style;es.left = 1 + el.offsetLeft + \"px\";es.top = 1 + el.offsetTop + \"px\"; 前面说过，这种写法会使浏览器强制重排获取正确的属性值，每次 ＋ 1 都会触发重排，我们可以将移动信息做缓存，如下 123var es = el.style, positionNum = el.offsetLeft;es.left = ++positionNum; 这样，我们就避免了，多次重排!","link":"/2015/09/01/repaints-and-reflows/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"}],"categories":[{"name":"FrontEnd","slug":"FrontEnd","link":"/categories/FrontEnd/"}]}