---
title: "JS基于时间的动画"
date: 2016-01-01
thumbnail: https://images.unsplash.com/photo-1601850494422-3cf14624b0b3?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2100&q=80
categories: FrontEnd
toc: true
tags:
  - JS
---

说起前端动画,不得不提 CSS 动画和 JS 动画,这里简单谈谈这两者.

CSS 动画简单方便,在样式表中就可以管理动画的内容,但相应的可维护性也随之降低;对动画的控制能力不足,比如说拖拽动画等等无法实现;放弃了物理动效的支持,只能通过缓动函数来模拟.
相比之 JS 动画则依托完备的编程语言,可以对动效的设计进行无限的控制,虽然编写起来相比 CSS 动画来说较为复杂,但可以通过一些第三方库来快速实现,比如 [VelocityJS](http://julian.com/research/velocity/) . 当然,事物的好坏永远需要按场景区分, CSS 动画和 JS 动画也是如此,比如说一个简单的按钮 hover 效果,无论怎么看 CSS 动画都是第一选择,但是如果需要控制一个动画工作流,那 JS 动画一定更适合了.

<!--more-->

有点跑题了..., 回到正文

## 关键帧动画

假如现在我们有这样一个需求 `让一个 div 向右边移动 300px 的距离`，我们来看看下面这种实现：
{% jsfiddle dq7Ldctf js,result %}

看起来我们实现了这个需求，不过不要急,我们稍稍修改上面代码中的 step 函数,在其中加入这段代码:

```javascript
if (left == 200) {
  var start = +new Date();
  while (+new Date() - start < 1000) {} //阻塞1s
}
```

大家可以去 jsfiddle 中加入这段代码，观察后，不难发现这个 div 在 left 值为 200px 的地方停顿了 1000+ms。大家都知道 js 是基于事件模型的，我们在 step 函数中 setInterval 其实相当于告诉引擎,帮我在 16.7 毫秒后将这个回调函数加入事件队列,如果引擎空闲就执行,此时我们 while 循环 1 秒，就会阻塞整个事件队列的运行，也就阻塞了 UI 线程的渲染，表现出来结果就是我们的 div 运动停止了 1 秒多。

这里虽然是人为的加入了阻塞代码，但是在正常的开发过程中，setInterval 和 setTimeout 根本没法保证按我们要求的在固定的间隔执行事件，此时如果我们的动画还是按照 `变化量/帧` 的方式来执行，就会出现不同设备中动画执行时间不同的情况,在移动端是重灾区。

## 基于时间的动画

在讨论上面所述的问题该如何解决之前，不妨先来看看这个数学题:

> A 地和 B 地相距 300m，一辆速度为 5m/s 匀速运动的自行车从 A 地出发去往 B 地,请问一分钟后自行车距离 A 地多远?

我们用时间 时间 _ 速度 即可得出 5 _ 60 = 300,也就是 300m，从这个简单的问题中，我们可以发现我们不必去寄人篱下一帧帧的做动效，不必去管帧率的问题,我们可以从动画开始时间到当前时间计算出动画经过的时间，通过 时间 \* 速度，计算出当前动画的偏移量，这样就可以保证我们所有性能的平台下动画都是一个速度进行着。下面我们来修改下上面的代码:
{% jsfiddle rbdk6z79 js,result %}

这里我们改为根据时间来计算偏移量，我的测试环境中弹出的结果应该在 `4801`，下面我们来看看加入同样阻塞代码后的用时，是不是也增加了 1000 毫秒那:
{% jsfiddle 2yr24asu js,result %}
我的测试环境弹出的是 `4865`，可以看出虽然加入了阻塞代码，但是因为我们是按照时间来计算偏移量的，所以动画总时间不会偏差过大，各个平台下动画也不会出现有的快有的慢得情况。

## 总结

基于时间的动效能够消除不同设备不同环境下动画帧数不同导致的动效速度不同的问题，推荐所有的动效都应该采用基于时间的方式!
